<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J.A.R.V.I.S</title>
  
  <subtitle>life is not just live</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.liunaijie.top/"/>
  <updated>2020-10-24T08:49:53.695Z</updated>
  <id>https://www.liunaijie.top/</id>
  
  <author>
    <name>Liu NaiJie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Clickhouse入门</title>
    <link href="https://www.liunaijie.top/2020/09/29/%E5%A4%A7%E6%95%B0%E6%8D%AE/Clickhouse%E5%85%A5%E9%97%A8/"/>
    <id>https://www.liunaijie.top/2020/09/29/%E5%A4%A7%E6%95%B0%E6%8D%AE/Clickhouse%E5%85%A5%E9%97%A8/</id>
    <published>2020-09-29T06:15:53.000Z</published>
    <updated>2020-10-24T08:49:53.695Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ClickHouse是什么&quot;&gt;&lt;a href=&quot;#ClickHouse是什么&quot; class=&quot;headerlink&quot; title=&quot;ClickHouse是什么&quot;&gt;&lt;/a&gt;ClickHouse是什么&lt;/h1&gt;&lt;p&gt;ClickHouse是一款数据库，在大数据量下的数据查询有很好的查询性能。&lt;/p&gt;
&lt;h2 id=&quot;适用场景：&quot;&gt;&lt;a href=&quot;#适用场景：&quot; class=&quot;headerlink&quot; title=&quot;适用场景：&quot;&gt;&lt;/a&gt;适用场景：&lt;/h2&gt;&lt;p&gt;在存储数据超过20万亿行的情况下，ClickHouse做到了90%的查询都能够在1秒内返回，所以ClickHouse基本能够胜任各种数据分析类的场景，并且随着数据体量的增大，它的优势也会变得越为明显。&lt;/p&gt;
&lt;h2 id=&quot;不适用场景&quot;&gt;&lt;a href=&quot;#不适用场景&quot; class=&quot;headerlink&quot; title=&quot;不适用场景&quot;&gt;&lt;/a&gt;不适用场景&lt;/h2&gt;&lt;p&gt;ClickHouse作为一款高性能OLAP数据库，在OLTP事务性操作的场景下，有以下几点不足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不支持事务&lt;/li&gt;
&lt;li&gt;不擅长根据主键按行力度进行查询（虽然支持）&lt;/li&gt;
&lt;li&gt;不擅长按行删除数据（虽然支持）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;与Kylin的对比&quot;&gt;&lt;a href=&quot;#与Kylin的对比&quot; class=&quot;headerlink&quot; title=&quot;与Kylin的对比&quot;&gt;&lt;/a&gt;与Kylin的对比&lt;/h2&gt;&lt;p&gt;Kylin是选定固定维度和指标后，通过预计算的方式，把结果存储起来，后续的查询通过查询这个预计算结果，可以更快的拿到结果。&lt;/p&gt;
&lt;p&gt;ClickHouse是一款数据库产品，它的每一次查询都需要一次计算产生，所以在维度固定的情况下，使用Kylin更好，因为每次查询ClickHouse都会消耗计算资源，而Kylin的查询消耗的资源基本可以忽略。&lt;/p&gt;
&lt;p&gt;ClickHouse在做关联查询时，效果不是很好。所以在ClickHouse中存储的表基本上都是大宽表。&lt;/p&gt;
&lt;p&gt;在查询维度和指标不确定的情况下，使用ClickHouse会更好。因为这个结果在Kylin中可能没有预先设置。&lt;/p&gt;
&lt;p&gt;个人感觉，在一些给老板看的固定报表场景下使用Kylin更好一些。在开发，数据分析的场景下，使用ClickHouse会更好一些。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://www.liunaijie.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="big data" scheme="https://www.liunaijie.top/tags/big-data/"/>
    
      <category term="clickhouse" scheme="https://www.liunaijie.top/tags/clickhouse/"/>
    
      <category term="kubernetes" scheme="https://www.liunaijie.top/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubetnetes的一些概念和术语</title>
    <link href="https://www.liunaijie.top/2020/08/30/docker%E4%B8%8EKubernetes/Kubernetes%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/"/>
    <id>https://www.liunaijie.top/2020/08/30/docker%E4%B8%8EKubernetes/Kubernetes%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/</id>
    <published>2020-08-30T02:05:39.000Z</published>
    <updated>2020-09-12T09:51:26.156Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;此篇文章来自《Kubernetes权威指南：从Docker到Kubernetes实践全接触（第4版） 》&lt;/p&gt;
&lt;p&gt;会对以下的内容在原有的基础上添加自己的修改和思考。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Master, Node&lt;/li&gt;
&lt;li&gt;Pod&lt;/li&gt;
&lt;li&gt;Label&lt;/li&gt;
&lt;li&gt;Replication Controller(Replica Sets)&lt;/li&gt;
&lt;li&gt;Deployment&lt;/li&gt;
&lt;li&gt;StatefulSet&lt;/li&gt;
&lt;li&gt;Service&lt;/li&gt;
&lt;li&gt;Job&lt;/li&gt;
&lt;li&gt;Volume&lt;/li&gt;
&lt;li&gt;Persistent Volume（Persistent VolumeClaim）&lt;/li&gt;
&lt;li&gt;Namespace&lt;/li&gt;
&lt;li&gt;Annotation&lt;/li&gt;
&lt;li&gt;ConfigMap&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;k8s里面的大部分资源都可以被看作一种资源对象，这些对象大部分也都可以通过&lt;code&gt;kubectl&lt;/code&gt;工具（或者是API调用）执行增删改查等操作，并将其状态保存在etcd中持久化存储。&lt;/p&gt;
&lt;p&gt;在这些调用中，有一个版本的概念：&lt;code&gt;apiVersion&lt;/code&gt;。对于一个接口有时候会进行升级，从而会有不同的版本存在，我们调用不同版本的接口从而对应不同版本的实现。在&lt;code&gt;k8s&lt;/code&gt;里面也是如此，需要在调用时指明现在调用的版本号。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://www.liunaijie.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="kubetnetes" scheme="https://www.liunaijie.top/tags/kubetnetes/"/>
    
  </entry>
  
  <entry>
    <title>大数据分析工具之-kylin</title>
    <link href="https://www.liunaijie.top/2020/07/19/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E4%B9%8B-kylin/"/>
    <id>https://www.liunaijie.top/2020/07/19/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E4%B9%8B-kylin/</id>
    <published>2020-07-19T01:04:19.000Z</published>
    <updated>2020-09-13T23:06:32.582Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kylin是什么&quot;&gt;&lt;a href=&quot;#kylin是什么&quot; class=&quot;headerlink&quot; title=&quot;kylin是什么&quot;&gt;&lt;/a&gt;kylin是什么&lt;/h1&gt;&lt;p&gt;在进行数据分析时，随着数据量的提升，处理时间基本也是线性增长。kylin是一个预处理框架，它将一些预先定义的复杂分析预先完成并进行存储，预处理完成后，再次进行请求时，kylin可以进行亚秒级别的响应。&lt;/p&gt;
&lt;p&gt;它是一个分析型数据仓库（也是OLAP引擎），为Hadoop提供标准SQL支持大部分查询功能&lt;/p&gt;
&lt;p&gt;可以接入kafka等实时流处理数据，从而可以在妙极延迟下进行实时数据等多维分析。&lt;/p&gt;
&lt;p&gt;处理引擎可以选用MapReduce和Spark。&lt;/p&gt;
&lt;p&gt;于BI工具无缝整合，可以接入Tableau，PowerBI/Excel，SuperSet等可视化分析工具。&lt;/p&gt;
&lt;p&gt;我总结出来的观点呢就是：当我们的数据量非常大之后，每次查询都需要花费很多时间，这时我们将查询结果缓存起来，后面查询从这个缓存里面查询速度就会非常快。在kylin中，将结果缓存到hbase表中。&lt;/p&gt;
&lt;p&gt;这里需要预先设置一些维度和度量，所以说适合一些固定报表等一些维度固定的场景，如果说维度的组合太多或者变化很频繁，可能不是很适用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://www.liunaijie.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="kylin" scheme="https://www.liunaijie.top/tags/kylin/"/>
    
      <category term="big data" scheme="https://www.liunaijie.top/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>Z字形变换—LeetCode6</title>
    <link href="https://www.liunaijie.top/2020/07/02/LeetCode/Z%20%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2-LeetCode6/"/>
    <id>https://www.liunaijie.top/2020/07/02/LeetCode/Z%20%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2-LeetCode6/</id>
    <published>2020-07-02T14:03:47.000Z</published>
    <updated>2020-09-13T23:24:16.227Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。&lt;/p&gt;
&lt;p&gt;比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;L   C   I   R&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E T O E S I I G&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E   D   H   N&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。&lt;/p&gt;
&lt;p&gt;请你实现这个将字符串进行指定行数变换的函数：&lt;/p&gt;
&lt;p&gt;string convert(string s, int numRows);&lt;br&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: s = “LEETCODEISHIRING”, numRows = 3&lt;br&gt;输出: “LCIRETOESIIGEDHN”&lt;br&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入: s = “LEETCODEISHIRING”, numRows = 4&lt;br&gt;输出: “LDREOEIIECIHNTSG”&lt;br&gt;解释:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;L     D     R&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E   O E   I I&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E C   I H   N&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;T     S     G&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://www.liunaijie.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://www.liunaijie.top/tags/java/"/>
    
      <category term="leetcode" scheme="https://www.liunaijie.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>我目前的git工作流程</title>
    <link href="https://www.liunaijie.top/2020/06/20/git/%E6%88%91%E7%9B%AE%E5%89%8D%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.liunaijie.top/2020/06/20/git/%E6%88%91%E7%9B%AE%E5%89%8D%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</id>
    <published>2020-06-20T11:33:15.000Z</published>
    <updated>2020-09-13T23:16:15.991Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;好久没写博客了。。。&lt;/p&gt;
&lt;p&gt;记录一下我在现在公司的一个git工作流程。&lt;/p&gt;
&lt;p&gt;我之前使用git是不同用户在同一个git仓库下进行操作，而现在是使用fork出自己的仓库，通过提pr的方式来进行提交代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://www.liunaijie.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="git" scheme="https://www.liunaijie.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git fork后如何与原仓库同步</title>
    <link href="https://www.liunaijie.top/2020/05/08/git/git%20fork%E5%90%8E%E5%A6%82%E4%BD%95%E4%B8%8E%E5%8E%9F%E4%BB%93%E5%BA%93%E5%90%8C%E6%AD%A5/"/>
    <id>https://www.liunaijie.top/2020/05/08/git/git%20fork%E5%90%8E%E5%A6%82%E4%BD%95%E4%B8%8E%E5%8E%9F%E4%BB%93%E5%BA%93%E5%90%8C%E6%AD%A5/</id>
    <published>2020-05-08T13:08:39.000Z</published>
    <updated>2020-09-13T23:16:21.454Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;当参与到开源项目开发后，我们需要先将代码fork到自己的仓库，对代码进行修改后再提交pr。&lt;/p&gt;
&lt;p&gt;如果在这中间原仓库有提交过代码，我们这边是无法得知的，所以我们需要在提pr前先进行merge操作，先将原仓库的内容更新下来再进行提交。&lt;/p&gt;
&lt;p&gt;大体流程如下所示：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liunaijie/images/master/git%20fork.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://www.liunaijie.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="git" scheme="https://www.liunaijie.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="https://www.liunaijie.top/2020/04/14/NoSQL/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://www.liunaijie.top/2020/04/14/NoSQL/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2020-04-14T05:25:33.000Z</published>
    <updated>2020-09-13T23:24:49.600Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要持久化数据&quot;&gt;&lt;a href=&quot;#为什么要持久化数据&quot; class=&quot;headerlink&quot; title=&quot;为什么要持久化数据&quot;&gt;&lt;/a&gt;为什么要持久化数据&lt;/h1&gt;&lt;p&gt;由于Redis是在内存中进行存储的，当机器重启后内存里面的数据就会丢失。我们不希望这些数据是临时数据，希望它能在重启之后仍然存在，或者我们能将数据导出在其他机器上直接进行导入。这时候都需要进行持久化，将数据落盘。&lt;/p&gt;
&lt;h1 id=&quot;持久化的方式&quot;&gt;&lt;a href=&quot;#持久化的方式&quot; class=&quot;headerlink&quot; title=&quot;持久化的方式&quot;&gt;&lt;/a&gt;持久化的方式&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;持久化的方式在&lt;code&gt;Redis 4.x&lt;/code&gt;版本后有了一些区别！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;持久化方式主要有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RDB&lt;/li&gt;
&lt;li&gt;AOF&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://www.liunaijie.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="redis" scheme="https://www.liunaijie.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>最小的k个数-LeetCodeM40</title>
    <link href="https://www.liunaijie.top/2020/04/13/LeetCode/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0-LeetCodeM40/"/>
    <id>https://www.liunaijie.top/2020/04/13/LeetCode/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0-LeetCodeM40/</id>
    <published>2020-04-13T04:29:33.000Z</published>
    <updated>2020-09-13T23:23:56.372Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 &lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：arr = [3,2,1], k = 2&lt;br&gt;输出：[1,2] 或者 [2,1]&lt;br&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入：arr = [0,1,2,1], k = 1&lt;br&gt;输出：[0]&lt;/p&gt;
&lt;p&gt;限制：&lt;/p&gt;
&lt;p&gt;0 &amp;lt;= k &amp;lt;= arr.length &amp;lt;= 10000&lt;br&gt;0 &amp;lt;= arr[i] &amp;lt;= 10000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;给定一个数组，找出最小的k个数，对这k个数的大小顺序没有要求。&lt;/p&gt;
&lt;h1 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h1&gt;&lt;p&gt;这个题目我最开始的想法是用堆来解决的，但我解答完成看题解的时候发现了一种做法：&lt;/p&gt;
&lt;p&gt;排序后取前k个元素&lt;/p&gt;
&lt;p&gt;在评论区中有很多人在讨论这一种解法，虽然的他复杂度比较高，实现方式很简单，有一些专业人士在鄙视这种做法，也有一些人说这个题目的难度是简单，所以用这个也没什么问题。我的看法是支持这种做法，并不因为他的难度级别，而是解决问题的思路。在解决问题的时候每一种思路都是可取的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://www.liunaijie.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://www.liunaijie.top/tags/java/"/>
    
      <category term="leetcode" scheme="https://www.liunaijie.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>堆以及堆排序</title>
    <link href="https://www.liunaijie.top/2020/04/12/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E4%BB%A5%E5%8F%8A%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://www.liunaijie.top/2020/04/12/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E4%BB%A5%E5%8F%8A%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-12T01:56:34.000Z</published>
    <updated>2020-09-13T23:11:52.137Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是堆&quot;&gt;&lt;a href=&quot;#什么是堆&quot; class=&quot;headerlink&quot; title=&quot;什么是堆&quot;&gt;&lt;/a&gt;什么是堆&lt;/h1&gt;&lt;p&gt;堆是一种特殊的树，它满足以下两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;堆是一个完全二叉树&lt;/p&gt;
&lt;p&gt;  完全二叉树要求，除最后一层，其他层的节点个数都是满的，最后一次的节点都靠左排列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值&lt;/p&gt;
&lt;p&gt;  当前节点的值是子树中的最大或最小值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们将每个节点的值都大于等于子树中每个节点值的堆，叫做“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫做“小顶堆”&lt;/p&gt;
&lt;p&gt;我们来看一下例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liunaijie/images/master/20200413141220.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上面的四个实例中，我们根据以上两条规则，可以判断出：&lt;/p&gt;
&lt;p&gt;第一个、第二个是大顶堆，第三个是小顶堆，第四个由于不是完全二叉树所以不是堆。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://www.liunaijie.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法与数据结构" scheme="https://www.liunaijie.top/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>什么是fail-fast与fail-safe</title>
    <link href="https://www.liunaijie.top/2020/04/01/java/%E4%BB%80%E4%B9%88%E6%98%AFfail-fast%E4%B8%8Efail-safe/"/>
    <id>https://www.liunaijie.top/2020/04/01/java/%E4%BB%80%E4%B9%88%E6%98%AFfail-fast%E4%B8%8Efail-safe/</id>
    <published>2020-04-01T02:23:53.000Z</published>
    <updated>2020-09-13T23:16:38.030Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;fail-fast与fail-safe&quot;&gt;&lt;a href=&quot;#fail-fast与fail-safe&quot; class=&quot;headerlink&quot; title=&quot;fail-fast与fail-safe&quot;&gt;&lt;/a&gt;fail-fast与fail-safe&lt;/h1&gt;&lt;p&gt;在Collection集合的各个类中，有线程安全和线程不安全这2大类的版本。&lt;/p&gt;
&lt;p&gt;对于线程不安全的类，并发情况下可能会出现fail-fast情况；而线程安全的类，可能出现fail-safe的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快速失败（fail—fast）&lt;/strong&gt;是java集合中的一种机制， 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全失败（fail-sage）&lt;/strong&gt;保存了该集合对象的一个快照副本。你可以并发读取，不会抛出异常，但是不保证你遍历读取的值和当前集合对象的状态是一致的！&lt;/p&gt;
&lt;h1 id=&quot;fail-fast&quot;&gt;&lt;a href=&quot;#fail-fast&quot; class=&quot;headerlink&quot; title=&quot;fail-fast&quot;&gt;&lt;/a&gt;fail-fast&lt;/h1&gt;&lt;p&gt;来看一下线程不安全的类&lt;code&gt;ArrayList&lt;/code&gt;，它实现&lt;code&gt;fail-fast&lt;/code&gt;主要靠一个字段&lt;code&gt;modCount&lt;/code&gt;。来从头认识一下它。&lt;/p&gt;
&lt;p&gt;首先找到引用它的地方：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(E e)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ensureCapacityInternal(size + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;// Increments modCount!!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  elementData[size++] = e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ensureCapacityInternal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; minCapacity)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ensureExplicitCapacity&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; minCapacity)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  modCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// overflow-conscious code&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (minCapacity - elementData.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    grow(minCapacity);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;title&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  rangeCheck(index);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  modCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  E oldValue = elementData(index);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; numMoved = size - index - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (numMoved &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.arraycopy(elementData, index+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, elementData, index,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     numMoved);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  elementData[--size] = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// clear to let GC do its work&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; oldValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以看出，在增加元素，删除元素时都会对&lt;code&gt;modCount&lt;/code&gt;值加一。当我们查看更新，查找的代码时并没有找到对&lt;code&gt;modCount&lt;/code&gt;的修改。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;modCount&lt;/code&gt;字段翻译过来就是&lt;code&gt;修改次数&lt;/code&gt;，再结合上面的代码可以了解到只有在结构发生变化，数量增减的时候才会修改。查找不会对结构发生变化也不用修改，至于更新操作，虽然它修改了值，但是在结构上总体的数量没有改变，结构上指的是：是谁不重要，有就行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://www.liunaijie.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://www.liunaijie.top/tags/java/"/>
    
  </entry>
  
</feed>
